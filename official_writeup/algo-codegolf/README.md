# [Algorithm] 神秘计算器

- 命题人：debugger
- 素数判断函数：200 分
- Pell数（一）：200 分
- Pell数（二）：300 分

## 题目描述

<p>欢迎使用神秘计算器 Python 版。本计算器支持<strong>四则运算和乘方</strong>，还提供了自定义函数功能。</p>
<p>但是作为试用版计算器，本计算器有如下限制：</p>
<ul>
<li>只支持输入整数</li>
<li>函数定义只支持小于 50 个字符</li>
</ul>
<p>你能用这个计算器做什么呢？</p>
<ol>
<li>试试实现一个函数，判断给定的数<strong>是不是素数。</strong></li>
<li>试试实现一个函数，计算<strong>第 n 个 <a target="_blank" rel="noopener noreferrer" href="https://www.baidu.com/s?word=pell数&amp;rsv_dl=DQA_PC_COPY">Pell 数</a>。</strong>如果你只能算对前几个 Pell 数，你可以拿到部分分数。</li>
</ol>
<p>注：此题是 Algorithm 题，无需绕过沙箱执行其他代码或获取系统权限。</p>
<div class="well">
<p><strong>第二阶段提示：</strong></p>
<ul>
<li>在 Python 中，可以用 <code>x//1</code> 取得 <code>x</code> 的整数部分（如果 <code>x</code> 是浮点数，结果还是浮点数）；还有，<code>0**0==1</code>。</li>
<li>Flag 1：了解一下费马素性检验以及什么是伪素数和 Carmichael 数。</li>
<li>Flag 2：Pell 数的通项公式是什么？近似计算公式呢？</li>
<li>Flag 3：可以看看<a target="_blank" rel="noopener noreferrer" href="https://blog.paulhankin.net/fibonacci/">这里</a>。另外，某个网站上你能找到一个类似的公式。</li>
<li>对 Flag 3 的长度限制将放宽到小于 100 个字符。</li>
</ul>
</div>

**[【附件：下载题目源码（algo-codegolf.py）】](attachment/algo-codegolf.py)**

**【终端交互：连接到题目】**

## 预期解法

### 素数判断函数
由于费马小定理，n为素数时`(2**n-2)%n==0`，从而有费马素性检验：`0**((2**n-2)%n)`用于判定一个数是否是素数。对于素数，这个表达式一定返回0。有少数合数也会使表达式返回0，这些数称为（模2的）伪素数。500以内的伪素数只有341。对于本题来说，可以用`0**((2**n-2)%n+0**((n-341)**2)))`来排除掉341。

### Pell数
Pell数有一个类似Binet公式的通项公式： $P_n=\frac{\left(1+\sqrt2\right)^n-\left(1-\sqrt2\right)^n}{2\sqrt2}$ ，也就是`((1+2**(1/2))**(n-1)-(1-2**(1/2))**(n-1))/2**(3/2)`（Python表达式，注意题目的n从1开始）。但是因为浮点误差，直接提交这个表达式是无法通过的。需要对结果取整：`(((1+2**(1/2))**(n-1)-(1-2**(1/2))**(n-1))/2**(3/2)+1/2)//1`，但是这个表达式已经达到50字符。注意`(1-2**(1/2))**n`是绝对值小于1的数，可以忽略掉，也就是`((((1+2**(1/2))**(n-1))/2**(3/2)+1/2)//1`。

上面的表达式不能用于Flag 3，因为双精度浮点数最多只能精确表示2^53以内的整数，而且Flag 3要求返回的是整数。需要精确计算第200项必须要其他方法。

生成函数是一种用每一项的系数表示数列的幂级数，也即 $\sum_{n=0}^\infty a_n x^n$ 。很多数列的生成函数具有封闭表达式，例如Pell数的生成函数是`x/(1 - 2*x - x^2)`（可以直接在<a href="https://oeis.org/A000129">OEIS</a>上找到）。如果我们代入x=1/1000，得到的数0.0010020050120290703，其中前几位（看成1000进制数）分别是1, 2, 5, 12, 29, 70，也就是Pell数的前几项。假如我们要提取出里面的29，可以用（Python表达式）`((1/1000)/(1-2/1000-1/1000**2)*(1000**5))//1%1000`。然后我们把分数两边乘以1000的平方，并把里面的除法改成整除，这样得到的结果是精确的整数：`(1000*1000**5)//(1000**2-2*1000-1)%1000`

回到原题，把1000换成m，然后再考虑计算第n项，公式是`(m**n)//(m**2-2*m-1)%m`。这里m需要取一个任意的大整数（必须大于可能的结果），例如取m=2^1000，化简后的表达式是`(2**(1000*n))//(2**2000-2**1001-1)%(2**1000)`。

## 其他解法

验题人在验此题时，最开始被长度限制卡了，于是非常生气，就卷了一下三道题的长度。验题人的解答在[sol文件](./sol/sol.txt)中。三道题的长度分别是34，35，33。当然第二题可以直接交第三题的答案，不过没有必要，还是使用一下期望解法。

赛后我统计了一下三问中选手提交的所有解答及其长度。选手们提交的答案都非常多样，分布还是比较均匀的。做法也有多种，且使用不同方式所压出来的式子也不太一致。

第一问的最短解答只有19字符，为 `1//(10103**(n-1)%n)`。不难发现这也是一个非常经典的伪素数判定方式。只是这位选手找到了一个非常短且好的底数，使得检查范围内的所有素数和合数均可以正确通过判定。去写一个程序枚举找到这样的数字也不难。其他选手的也采用了不同但类似的伪素数判定方法，例如使用多个底数同时判定，或者像预期解法一样单独排除掉一个数字。

第二问的最短期望解答有33字符，比我构造的短2个。为 `((1+2**(1/2))**(n-1)+1)//2**(3/2)`。不难发现这个构造和我的其实是一样的，只是使用了整除代替了我单独加的`//1`取整。这个表达式同样是基于预期解法上的，而且在化简方式中，仅仅使用了常规的表达式化简方法，同时把取整系数挪到分子的括号内。由于这个取整不需要太高的精度，所以在分子上直接`+1`也可以得到正确结果。这一问有很多同学都给出了神秘但类似的解答。例如某位同学构造了`(6625109*(93222358/38613965)**(n-1)/9369319+1)//2`长度正好为49的解答。显然，这位同学并没有发现我们可以使用`2**(1/2)`的方式开根，而是大力使用分数逼近构造了一个`2**(1/2)+1`。

第三问的最短解答为29个字符，比我构造的短4个，为`9**n**2//((9**n-1)**2-2)%9**n`。和我的解答的区别是分母做了一下整理，更短了。这个构造的具体做法和预期解法是一致的，只是带入的数字替换成了`9**n`，并做了一些表达式化简。当然本题还有多种其他做法，例如有十几位同学直接找到了OEIS的FORMULA栏目的最后一行，将其写成了Python表达式并通过了此题(不过看起来大部分同学都和我一样并没有注意到这一行)。还有大量的数理基础扎实的同学(例如[这位同学](../../players_writeup/1047/README.md#flag3-4))，构造了一个可以表达根号2的模意义下的环，并在上面做了一定的数学推导，进而得出了此题的解。