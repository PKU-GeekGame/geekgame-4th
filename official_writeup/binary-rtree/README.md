# [Binary] 生活在树上

- 命题人：Rosayxy
- Level 1：200 分
- Level 2：200 分
- Level 3：300 分

## 题目描述

<p>小 R 同学是个计算机系的学生。他听说在数据结构的课上，要求手搓二叉树。     </p>
<p>小 R 同学虽然不会写二叉树，但是他认真思考，进行了多次尝试。       </p>
<p>在一开始，小 R 同学不知道动态分配内存为何物，于是<strong>在栈上开辟出数组，</strong>用来插入申请的节点，为了不产生溢出。他做了必要的检查。        </p>
<p>小 R 同学继续学习，此时他不仅学了<strong>堆空间</strong>，更接触到了<strong>链表的数据结构</strong>。小 R 同学灵光一现：链表也就是一种特殊的树吖！于是他手搓了一个链表，并且实现了基本操作。           </p>
<p>最后，小 R 同学终于学到了<strong>二叉树</strong>，他发现这真是太神奇了！小 R 同学动手搓了一个基础版的二叉树，并且按照他的理解进行了创新。           </p>
<p>你看到了小 R 同学的三份代码，发现其中都存在漏洞。你决定利用这些漏洞，让小 R 同学明白内存安全的重要性。（小 R 同学：别骂了我错了，下次一定注意qwq）</p>
<div class="well">
<p><strong>第二阶段提示：</strong></p>
<ul>
<li>这类题属于 pwn 类型，需要找到二进制程序的漏洞并且加以利用，构造恶意输入来 get shell (对于本题中的程序，如果在远程可以成功执行 <code>system("/bin/sh")</code> 即可提权)</li>
<li>level1: 有师傅反映有执行到 <code>backdoor</code> 之后会 crash,可以看一下 crash 的那一条指令对栈对齐有什么要求(本地调试请用 ubuntu 22.04 及以上版本)，然后如何解决（提示：可以在 ROPchain 中加 ret 指令来升栈）</li>
<li>level2: 可以试一下劫持结构体中函数指针为 <code>backdoor</code></li>
<li>level3: libc 2.31 的堆 pwn 可以用 tcache poisoning，拿到任意写后打 free_hook</li>
</ul>
</div>

**[【附件：下载题目附件（binary-rtree.zip）】](attachment/binary-rtree.zip)**

**【终端交互：连接到第一关】**

**【终端交互：连接到第二关】**

**【终端交互：连接到第三关】**

## 预期解法

### Level 1
- 本题代码逻辑是在栈上实现了一个节点数组，对于数组中的每一项，都是一个 `Node` 结构体和它的数据，此外用一个全局变量数组来维护每一项地址范围的上界

- 漏洞在于，在读入数据时，`read` 函数第三个参数应该是输入的 `data` 的长度，但是这里写成了 `size + sizeof(Node)` 的形式，所以可以溢出 24 字节

- 我们直接覆盖返回地址为 `backdoor` 函数的地址，但是这样做会出现 segfault，有师傅也在群里和 feedback 中反映过这个问题，这是因为在 ubuntu 22.04 （即是本题采用的系统版本）之后，movaps 要求栈 8 字节对齐，`system` 函数中有 `movaps` 指令，所以说在劫持到 `backdoor` 函数中，有可能在 `movaps` 指令处崩掉，所以我们需要在 ROPchain 中加入一个 `ret` 指令来升栈，从而解决这个问题

### Level 2
- 本题实现了一个链表的数据结构，每一项由一个 0x28 大小的保存节点信息的堆块和一个保存数据的堆块组成

- 漏洞在于 `edit` 函数中，没有检查 siz 为负数的情况，所以可以往前写该保存节点信息的堆块

- 而在节点信息中，有一项是 `edit`，是函数指针类型，被初始化成了 `edit` 函数，如果对于该块还没有调用过 `edit` 功能，则会通过该函数指针进行调用，所以我们可以通过修改节点信息中的函数指针为 `backdoor` 函数的地址，从而 get shell

- 注意说这里不会出现 `movaps` 对齐的问题，但是如果在相同情况下出现了的话，可以通过覆盖函数指针为 0x40128f，即是少掉 `backdoor` 函数一开始的 `push rbp` 指令，从而解决

- 本题虽然结构体在堆上，但是只用大概知道堆块的结构和最最基础的分配方式就可以做，所以并不是堆题（

### Level 3

- 本题的附件下发了 libc-2.31.so，ld-2.31.so，可以用 [patchelf](https://github.com/NixOS/patchelf) 来更改二进制文件的运行时库，并用 `ldd` 指令检查是否 patch 成功

- 本题是个堆题，实现了对一个类二叉树的增删改查操作，但是和常规二叉树不同的地方是每个节点多了一个 `same_vals` 指针，指向 key 相同的节点，而在插入时，如果遇到树中有节点和插入节点 key 相同的话，则会把插入节点放到相同 key 节点 `same_vals` 链表的尾部

- 漏洞在于删除节点时，如果该节点的 `same_vals` 不为空，则不会将被删节点父节点的子节点指针置空，从而造成悬垂指针现象，可以 UAF（use after free）

- 后续的利用可以先泄露 unsorted bin 块中的 libc 地址和堆地址，再打 [tcache poisoning](https://github.com/shellphish/how2heap/blob/master/glibc_2.31/tcache_poisoning.c)，效果是拿到任意地址写，有一个需要注意的地方是被 free 掉的堆块的前若干个字节会被写，所以对应的 `key` 的值输入也需要相应的改变

- 然后覆盖 `free_hook` 为 `system` 函数的地址，再释放一个含有 `/bin/sh\x00` 字符串的堆块，就可以 get shell 了